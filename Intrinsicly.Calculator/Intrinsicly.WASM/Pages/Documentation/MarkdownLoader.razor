@page "/{**MarkdownPath}"
@using Intrinsicly.WASM.Services.Markdown
@using MudBlazor.Markdown.Extensions.Domain.DTOs
@inject IMarkdownService _markdownService

<MudContainer Style="overflow-y: hidden;">
    <MudGrid>
        <MudItem sm="1">

        </MudItem>
        <MudItem sm="10">
            @if (isRoadmap)
            {
                <Roadmap MarkdownPath="@MarkdownPath" />
            }
            else
            {
                <MarkdownPage MarkdownPath="@MarkdownPath" MarkdownContent="@MarkdownContent" />
            }
        </MudItem>
        <MudItem sm="1">

        </MudItem>
    </MudGrid>
</MudContainer>

@code {
    [Parameter]
    public string MarkdownPath { get; set; }

    private string MarkdownContent = "";
    private bool isRoadmap = false;
    private bool _isInitialized = false;

    protected override async Task OnInitializedAsync()
    {
        if (!_isInitialized)
        {
            await LoadContentAsync();
            _isInitialized = true;
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        if (_isInitialized)
        {
            await LoadContentAsync();
        }
    }

    private async Task LoadContentAsync()
    {
        await _markdownService.LoadCurrentMarkdownAsync();
        var currentMarkdown = _markdownService.CurrentMarkdown;

        if (IsCurrentMarkdownValid(currentMarkdown))
        {
            await HandleValidCurrentMarkdownAsync(currentMarkdown);
        }
        else if (IsDifferentMarkdownUrl(currentMarkdown))
        {
            await HandleDifferentMarkdownUrlAsync();
        }
        else
        {
            SetMarkdownUnavailable();
        }
    }

    private bool IsCurrentMarkdownValid(MarkdownInfoDto currentMarkdown)
    {
        return currentMarkdown != null && currentMarkdown.UrlPath == MarkdownPath;
    }

    private bool IsDifferentMarkdownUrl(MarkdownInfoDto currentMarkdown)
    {
        return currentMarkdown != null && currentMarkdown.UrlPath != MarkdownPath;
    }
 
    private void SetMarkdownUnavailable()
    {
        MarkdownContent = "Markdown information not available.";
        isRoadmap = false;
    }

    private async Task<string> GetMarkdownContentAsync(string directoryPath)
    {
        string content = await _markdownService.GetMarkdownContentAsync(directoryPath);
        return string.IsNullOrEmpty(content) ? "Markdown information not available." : content;
    }
}

@code {
    private async Task HandleValidCurrentMarkdownAsync(MarkdownInfoDto currentMarkdown)
    {
        if (currentMarkdown.DisplayName == "Roadmap")
        {
            isRoadmap = true;
        }
        else
        {
            MarkdownContent = await GetMarkdownContentAsync(MarkdownPath);
            isRoadmap = false;
        }
    }

    private async Task HandleDifferentMarkdownUrlAsync()
    {
        KeyValuePair<MarkdownInfoDto, string> markdown = await _markdownService.GetMarkdownEntityAsync(MarkdownPath);
        if (!string.IsNullOrEmpty(markdown.Value))
        {
            await _markdownService.SaveCurrentMarkdownAsync(markdown.Key);

            if (markdown.Key.DisplayName == "Roadmap")
            {
                isRoadmap = true;
            }
            else
            {
                MarkdownContent = markdown.Value;
                isRoadmap = false;
            }
        }
        else
        {
            SetMarkdownUnavailable();
        }
    }
}